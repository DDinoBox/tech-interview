# index

## 인덱스란
추가적인 쓰기 작업과 저장공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조 <br>
빠른 데이터 검색을 위해 컬럼의 값과 해당 레코드가 저장된 주소를 key-value 쌍으로 인덱스를 만들어두는 것이다. <br>

## 인덱스의 자료구조
인덱스를 구현하기 위한 자료구조는 여러가지가 있다. <br>
대표적으로 해시테이블과 B+ Tree가 있다. <br>

```해시테이블```
해시테이블은 key, value로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다. <br>
해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조이다. <br>
해시테이블 기반의 DB 인덱스는 (데이터 = 컬럼의 값, 데이터의 위치)를 (Key, Value)로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현하였다. <br>
하지만 DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 그 이유는 해시가 등호(=) 연산에만 특화되어있기 때문이다. <br>
해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>,<)이 자주 사용되는 데이터베이스 검색을 위해서는 해시테이블이 적합하지 않다. <br>
즉, 예를들어 "나는"으로 "시작하는"(부등호연산) 모든 데이터를 검색하기 위한 쿼리문은 인덱스의 혜택을 전혀받지 못하게된다. 이러한 이유로 데이터베이스의 인덱스에서는 B+ Tree가 일반적으로 사용된다.

```B Tree```
이진트리를 확장해서 더 많은 수의 자식을 가질 수 있게 일반화시킨 것이 B-Tree <br>
자식 수에 대한 일반화를 진행하면서 하나의 레벨에 더 저장되는 것 뿐만아니라 트리의 균형을 자동으로 맞춰주는 로직까지 갖춤. 단순하고 효율적이며, 레벨로만 따지면 완전히 균형을 맞춘 트리 <br>
▶ 따라서 균형잡힌 확장된 이진 탐색트리이므로 시간복잡도 O(logN)보장 <br>
대량의 데이터를 처리해야할 때 검색구조의 경우 하나의 노드에 많은 데이터를 저장할 수 있는 것은 상당히 큰 장점이다. <br>
대량의 데이터는 메모리보다 블럭단위로 입출력하는 하드디스크 or SSD에 저장해야하기 때문이다.

```규칙```
 - 최대 M개의 자식을 가질 수 있는 B트리를 M차 B트리라고 한다.
 - 노드의 자료수가 N이면, 자식수는 N+1이어야 한다.
 - 각 노드의 자료는 정렬된 상태여야한다.
 - 루트노드는 적어도 2개 이상의 자식을 가져야한다.
 - 루트노드를 제외한 모든 노드는 적어도 M/2개의 자료를 가지고있어야한다.
 - 외부 노드로 가는 경로의 길이는 모두 같다.
 - 입력 자료는 중복될 수 없다.


```B+ Tree``` <br>
B+ Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. <br>
B+ Tree는 모든 노드에 데이터(Value)를 저장했던 B Tree와 다른 특성을 가지고 있다. <br>
리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖는다. <br>
리프노드들은 LinkedList로 연결되어있다. <br>
데이터노드 크기는 인덱스 노드의 크기와 같지 않아도 된다. <br>
데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다. 이러한 이유로 B Tree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 B Tree를 인덱스에 맞게 최적화하였다.  <br>
(물론 Best Case에 대해 리프노드까지 가지 않아도 탐색할 수 있는 B Tree에 비해 무조건 리프노드까지 가야한다는 단점도 있다.) <br>
이러한 이유로 B+ Tree는 O(log2N)의 시간복잡도를 갖지만 해시테이블보다 인덱싱에 더욱 적합한 자료구조가 되었다.

```B Tree, B+ Tree 비교```
이진 트리는 하나의 부모가 두 개의 자식밖에 가지질 못하고, 균형이 맞지 않으면 검색 효율이 선형검색 급으로 떨어진다 (최악의 경우 편향된 구조로 시간복잡도 O(logN)) <br>
하지만 이진 트리 구조의 간결함과 균형만 맞다면 검색, 삽입, 삭제 모두 O(logN)의 성능을 보이는 장점이 있기 때문에 계속 개선시키기 위한 노력이 이루어지고 있다. <br>
B+ 트리는 B 트리의 변형구조로, 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드가 추가로 있다. <br>
기존의 B Tree와 데이터의 연결리스트로 구현된 색인구조이다. <br>
B Tree의 변형구조로 index부분과, leaf 노드로 구성된 순차데이터 부분으로 이루어진다.  <br>
인덱스 부분의 key값은 leaf에 있는 key 값을 직접 찾아가는데 사용된다. <br>
장점은 블럭사이즈를 더 많이 이용할 수 있다는 것 (key에 대한 값(value)에 대한 하드디스크 엑세스 주소가 없기 때문) <br>
leaf 노드끼리 연결리스트로 연결되어있어서 범위 탐색에 매우 유리하다. <br>
단점은 B Tree의 경우 최상 케이스에서는 루트에서 끝날 수 있지만, B+ Tree는 무조건 leaf 노드까지 내려가야한다. <br>
B Tree는 각 노드에 데이터가 저장된다. <br>
B+ Tree는 index노드와 leaf 노드로 분리되어서 저장된다. <br>
또한 leaf노드는 서로 연결되어 있어서 임의접근이나 순차 접근 모두 성능이 우수하다. <br>
B Tree는 각 노드에서 key와 data가 모두 들어갈 수 있고, data는 disk block으로 포인터가 될 수 있다. <br>
B+ Tree는 각 노드에서 key만 들어간다. 따라서 data는 모두 leaf 노드에만 존재한다. <br>
B+ Tree는 add와 delete가 모두 leaf노드에서만 일어난다. <br>

```정리``` <br>
인덱스는 데이터가 저장된 물리적 구조와 밀접한 관계가 있다. <br>
인덱스는 레코드가 저장된 물리적 구조에 접근하는 방법을 제공한다. <br>
레코드의 삽입과 삭제가 빈번하게 일어나는 경우, 인덱스의 개수를 최소로 하는 것이 효율적이다. <br>
인덱스가 없으면 특정한 값을 찾기위해 모든 데이터 페이지를 확인하는 TABlE SCAN이 발생한다. <br>
기본키를 위한 인덱스를 기본 인덱스라 하고, 기본 인덱스가 아닌 인덱스들을 보조 인덱스라고 한다.  <br>
대부분의 관계형 데이터베이스 관리 시스템에서는 모든 기본키에 대해서 자동적으로 기본 인덱스를 생성한다. <br>
레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성하는 인덱스를 클러스터드 인덱스라고 한다. <br>
```클러스터드 인덱스```
인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식 <br>
실제 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있다. <br>
데이터 삽입, 삭제 발생 시 순서를 유지하기 위해 데이터를 재정렬해야한다. <br>
한 개의 릴레이션에 하나의 인덱스만 생성 가능 <br>
```넌클러스터드 인덱스```
인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식 <br>
데이터를 검색하기 위해서는 먼저 인덱스를 검색하여 실제 데이터 위치를 확인해야 하므로 클러스터드 인덱스에 비해 검색 속도가 떨어진다. <br>
한 개의 릴레이션에 여러 인덱스를 만들 수 있다.

> 참고사이트 : 
> - https://velog.io/@syleemk/%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4
> - https://alreadyusedadress.tistory.com/355 [ :티스토리]
> - https://mangkyu.tistory.com/96

