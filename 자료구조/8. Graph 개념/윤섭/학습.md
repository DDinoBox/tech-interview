## 그래프(Graph)란?

그래프는 `정점(Vertex)`과 정점들을 연결하는 `간선(Edge)`로 구성이 된 자료 구조이다. 일반적으로 정점은 원으로 표현하고 간선은 화살표나 선분으로 표현한다.

간선을 화살표로 나타내는 경우에는 해당 방향으로만 이동할 수 있으며, 이러한 그래프를 `유향 그래프(Directed Graph)`라고 한다. 반대로 선분으로만 표현한 경우는 양방향 모두 이동 가능하며, 이러한 그래프는 `무향 그래프(Undirected Graph)`라고 한다. 그리고 간선의 경우 특정한 수치를 가질 수 있는데 이를 `가중치(Weighted Value)`라고 한다.

예를 들어 도시를 정점으로 생각하고 도시 사이를 잇는 도로를 간선으로 생각하면 그래프는 곧 하나의 지도가 된다. 여기에 각 도로마다 도로의 길이 또는 이용 요금을 써 넣으면 이것이 바로 그 도로의 가중치이다. 이 때 가중치가 없는 그래프는 `비가중치 그래프`라고 하며, 가중치가 있는 그래프는 `가중치 그래프`라고 한다.

> 정점: 서울, 인천, 부산<br>
> 간선: 서울-인천, 서울-부산, 인천-부산<br>
> 가중치: 5,000원(서울-인천의 통행료), 10,000원(서울-부산의 통행료), 15,000원(서울-부산의 통행료)

```javascript
// 자바스크립트 객체로 비유한 비가중치 그래프
const korea = {
    seoul: {
        incheon: true,
        busan: true,
    },
    incheon: {
        seoul: true,
        busan: true,
    },
    busan: {
        seoul: true,
        incheon: true,
    },
};
```

### 그래프에서 사용되는 용어

-   `인접 정점(Adjacent Vertex)`: 간선에 의해 연결된 정점
-   `단순 경로(Simple Path)`: 동일한 간선을 지나지 않는 경로
-   `차수(Degree)`: 무방향 그래프에서 한 정점에 인접한 정점의 수
-   `진출 차수(Out-degree)`: 방향 그래프에서 한 정점에서 다른 정점으로 나가는 간선의 수
-   `진입 차수(In-degree)`: 방향 그래프에서 외부에서 한 정점으로 들어오는 간선의 수
-   `자기 루프(Self Loop)`: 정점에서 진출하는 간선이 곧바로 자기 자신에게 진입하는 경우를 "자기 루프를 가졌다."라고 표현한다. 자기 루프는 **다른 정점을 거치지 않는다**는 것이 특징이다.
-   `사이클(Cycle)`: 한 정점에서 출발하여 다시 해당 정점으로 돌아갈 수 있다면 "사이클이 있다."라고 표현한다.

## 그래프의 구현 방법

### 인접 행렬(Adjacency Matrix)

2차원 배열로 그래프를 구현하는 방식. 간선이 존재하는 두 정점 칸은 1, 없는 칸은 0으로 넣고 만약 가중치가 다른 그래프라면 해당 가중치 값을 넣는다.

#### 인접 행렬의 특징

-   2차원 배열상에 그래프 정보가 담겨 있어 **간선의 존재 여부나 가중치를 빠르게 확인**할 수 있다: O(1)
-   간단하게 구현할 수 있다.
-   n<sup>n</sup> 크기의 2차원 배열 사용으로 **메모리가 필요 이상으로 사용**될 수 있다.
-   모든 간선 정보를 대입하는데 시간이 걸린다: O(n<sup>n</sup>)

### 인접 리스트(Adjacency List)

정점에 연결되어 있는 정점들만 리스트로 나타내는 방식.

#### 인접 리스트의 특징

-   필용한 만큼의 메모리만 사용하기 때문에 메모리 낭비가 없다.
-   정점들의 연결 정보를 확인하려 할 때는 간선의 갯수만큼의 탐색이 필요하다: O(n)(n: 정점에 연결된 간선의 수)
-   인접 행렬에 비해 시간이 오래 걸릴 수 있다.

## 그래프 탐색 방법

### 넓이 우선 탐색(BFS, Breadth-First Search)

정점을 기준으로 간선이 연결되어 있는 모든 정점들을 차례로 방문하고 찾고자 하는 정점을 만날 때 까지 반복한다. `Queue` 를 사용하여 많이 구현하므로 **선입선출**의 구조를 따른다.

### 깊이 우선 탐색(DFS, Depth-First Search)

정점을 기준으로 간선이 연결되어 있는 정점 들 중 하나를 선택해 이동하고 다시 이동한 정점을 기준으로 다시 인접 정점을 선택한다. 연결되어있는 간선을 따라 찾고자 하는 정점을 만날 때 까지 진행하고 찾지 못하면 다시 이전 정점으로 돌아와 반복한다. 재귀함수를 통해서 구현하기도 하고 혹은 `Stack`을 사용해 구현하기도 한다. 따라서 **선입후출**의 구조를 따른다.
