# 리액트의 불변성 (spread 문법 연관)

> **불변성이란 메모리 영역의 값을 변경할 수 없는 것** 인데, 리액트는 불변성을 지켜줌으로써 사이드 이펙트를 사전 방지하거나 프로그래밍 구조를 단순하게 유지하는 등의 효율적인 상태업데이트(얕은 비교 수행)를 할 수 있게된다.

- 사전적으로 불변성이란 값이나 상태를 변경할 수 없는 것을 말한다.

- 불변성을 가진 원시타입과 달리 **참조타입의 경우에는 의도적으로 불변성을 지켜주어야한다.** 이 때 **새로운 주소 값을 가진 객체를 생성하여 상태를 업데이트 해준다. spread operator, map, filter, slice, reduce 메소드들을 활용**한다.

<br>

### 리액트에서 불변성을 지키는 이유

#### 1. 효율적인 상태업데이트 (얕은 비교 수행)

- 리액트에서 불변성을 지켜주는 이유는 리액트가 상태 업데이트를 하는 원리 때문이다. 리액트는 상태값을 업데이트할 때 얕은 비교를 수행한다. 즉, 참조값만을 비교하여 상태 변화를 감지하는데, 이러한 이유 때문에 배열이나 객체를 업데이트할 때 `setState([...state, newState])` , `setState({...state}, [key]:value)` 와 같이 배열이나 객체를 새로 생성해서 새로운 참조값을 만든 후 상태를 업데이트 하게된다. 이러한 작업이 불변성을 지켜주는 것이다.

✍️ 얕은 비교란 객체의 프로퍼티를 하나하나 다 비교하지 않고, 객체의 참조 주소값만 변경되었는지 확인한다. 얕은 비교는 리소스를 줄여주므로 리액트는 효율적으로 상태를 업데이트 할 수 있다.

#### 2. 사이드 이펙트 방지 및 프로그래밍 구조의 단순성.

- 불변성을 지켜줌으로써 사이드 이펙트를 방지할 수 있다. 외부의 값을 함부로 변경할 수 있다는 것은 위험한데, 만약 다른 곳에서 원본데이터를 사용하고 있다면 사이드 이펙트가 일어날 가능성이 있기 때문이다. 즉, 외부에 존재하는 원본데이터를 직접 수정하지 않고, 원본데이터의 복사본을 만들어서 값을 사용하므로 예기치 못한 오류를 사전에 방지할 수 있다는 이점이 있다.

✍️ 원시타입은 애초에 불변성 특징을 가지고 있지만, 참조타입인 객체 혹은 배열의 경우 새로운 값을 변경할 때 원본 데이터가 변경된다. 즉, 불변성이 지켜지지 않는다.
원본데이터가 변경될 경우, 이 원본 데이터를 참조하고 있는 다른 객체에서 예상치 못한 오류가 발생할 수 있으며 프로그래밍 복잡도도 올라간다.
