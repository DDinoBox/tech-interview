## 리액트의 불변성

### 불변성이란?

사전적으로 **불변성이란 값이나 상태를 변경할 수 없는 것**을 의미한다.

자바스크립트에서 원시타입(`Boolean`, `String`, `Number`, `null`, `undefined`, `Symbol`)은 불변성을 가지고 있다. 대표적인 원시타입인 String 타입을 통해 예를 들어보자면

```javascript
let string = "a";
string = "b";
```

위 코드에서 변수 `string`이 `a`에서 `b`로 값이 변경된 것처럼 보이지만 실제 메모리 영역에서는 `a`와 `b`가 둘 다 존재한다.

만약 메모리 영역이 1~10까지 있다고 가정한다면

```javascript
let string = "a"; // string = 'a'는 메모리 영역 1에 등록
string = "b"; // string = 'b'는 메모리 영역 2에 등록
```

위 예시에서는 메모리 영역을 총 2개 사용했다. 변수 `string`은 `a`였고, 여기에 `b`를 재할당하였는데 기존 메모리 영역 1에 있는 `a`값은 그대로 두고, 메모리 영역 2에 `b`를 새로 할당한 것이다.

즉, 메모리 영역에서 `b`는 `a`를 대체하는 것이 아니라 새로운 영역에 할당된다. 이것이 바로 **불변성**이다.

참조타입(`Object`, `Array`)도 마찬가지이다.

```javascript
let arr = [1, 2, 3, 4]; // 메모리 영역 1에 할당
arr.push(5); // 메모리 영역 1에 할당

arr = [1, 2, 3, 4]; // 메모리 영역 2에 할당 (새로운 참조값)
```

위 예시에서 `arr.push(5)`는 원본 데이터를 수정함으로써 불변성을 지켜주지 않은 것이 되고, `arr = [1, 2, 3, 4]`는 새로운 배열 [1, 2, 3, 4]을 할당하고 새로운 참조값을 만들어 불변성을 지켜준 것이 된다.

불변성의 진짜 의미는 <span style="color: #336AF6">**메모리 영역에서 값을 변경할 수 없다**</span>는 의미이다.

## 리액트는 왜 불변성을 지켜야 하는 것인가?

리액트에서 불변성을 지켜주는 이유는 리액트가 상태 업데이트를 하는 방식때문이다. 리액트는 상태값을 업데이트 할 때 `얕은 비교`를 수행한다. 즉 객체의 속성 하나하나를 비교하는 것이 아니라 참조값만 비교하여 상태 변화를 감지한다. 이런 이유로 배열이나 객체를 업데이트 할 때 `setState([...state, newState]), setState({...state, [key]: value})`와 같은 식으로 배열이나 객체를 새로 생성, 새로운 참조값을 만들어 상태를 업데이트 한다. 이러한 행위가 불변성을 지켜주는 것이다.

불변성을 지켜줌으로써 얻는 추가적인 장점은 바로 사이드 이펙트를 방지하는 것이다. 원본 데이터를 직접 수정하지 않고, 복사본을 만들어 값을 사용하기에 예상치 못한 오류를 사전에 방지할 수 있다.

정리하자면 아래와 같은 이유로 리액트에서는 불변성을 지켜야 하는 것이다.

1. 효율적인 상태 업데이트 (얕은 비교 수행)<br>
   `얕은 비교`란 객체의 프로퍼티를 하나하나 다 비교하지 않고, 객체의 참조 주소값만 변경되었는지 확인하는 것이다. `얕은 비교`는 계산 리소스를 줄여주므로 리액트에서 효율적인 상태 업데이트가 가능해진다.

2. 사이드 이벡트 방지 및 프로그래밍 구조의 단순화<br>
   원시타입은 애초에 불변성을 가지고 있지만 참고타입인 객체나 배열은 새로운 값을 변경할 때 원본 데이터가 변경된다.(불변성이 지켜지지 않음) 이렇게 원본 데이터가 변경될 경우, 이 원본 데이터를 참조하고 있는 다른 객체에서 예상치 못한 오류가 발생할 수 있다.

## 어떻게 불변성을 지킬 수 있는가?

`spread operator`, `map`, `filter`, `slice`, `reduce`등 새로운 배열을 반환하는 메소드들을 활용하면 된다.

setState를 이용할 때 원시타입은 값을 바로 넣어주어도 되지만, 참조타입인 경우에는 새로운 객체나 배열을 생성한 후 값을 넣어주어야 한다.

```javascript
// 원시타입
const [number, setNumber] = useState(0);
setNumber(3);

// 참조타입
const [user, setUser] = useState({
    name: "",
    age: 20,
});

setUser({ ...user, name: "younseop" });
```
