# 📌 JavaScript

## 1-1. var, let, const 의 차이점

> 변수를 선언할 때 사용할 수 있는 키워드로는 **var, let, const**가 있다. **var** 키워드의 문제점은 중복선언을 허용하고 변수 호이스팅이 발생하며, 함수 레벨 스코프로 인해 함수 외부에서 선언한 변수는 모두 전역 변수로 된다는 것이다. 따라서, 이를 보완하기 위해 나온 ES6 문법인 **let** 혹은 **const**를 사용하는 것이 좋다.

### 변수란?

**변수**는 값의 위치(주소)를 기억하는 저장소이다. 값의 위치란 값이 위치하고 있는 메모리 상의 주소를 의미한다. 즉, 변수란 값이 위치하고 있는 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 명명한 식별자(identifier)이다.

변수의 선언은 `var`, `const`, `let` 키워드로 할 수 있으며, ES6에서 `const`와 `let`이 추가되었다.

![](https://velog.velcdn.com/images/seul06/post/cc01d158-97e1-43bf-9d71-76e379514981/image.png)

<br>

### var 키워드의 문제점

1. 함수 레벨 스코프(Function-level scope)
   전역 변수의 남발
   for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 있다.

2. var 키워드 생략 허용
   의도하지 않은 변수의 전역화

3. 중복 선언 허용
   의도하지 않은 변수값 변경

4. 변수 호이스팅
   변수를 선언하기 전에 참조가 가능하다.

<br>

### 자바스크립트 스코프의 특징

#### 📌 자바스크립트는 함수 레벨 스코프(function-level scope)를 따른다.

함수 레벨 스코프란 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다(참조할 수 없다)는 것이다.

**단, ECMAScript 6에서 도입된 let keyword를 사용하면 블록 레벨 스코프를 사용할 수 있다.**

<br>

### let과 const

이 둘의 차이점은 'immutable' 여부이다.
**let 은 변수에 재할당이 가능하지만, const는 변수 재선언, 변수 재할당 모두 불가능하다.**

❗️ 이와 같기 때문에 기존의 `var` 대신 ES6에 추가된 `let` 혹은 `const` 를 사용하는 것이 좋다.
즉, 기본적으로는 의도치 않은 재할당을 방지해 줄 수 있는 `const` 를 사용하고, 재할당이 필요한 경우에 한정해 `let` 을 사용하는 것이 좋다.
![](https://velog.velcdn.com/images/seul06/post/3f972f70-4c38-4548-9b9c-982ea27df4fd/image.png)

> 📌 [변수 정리](https://velog.io/@seul06/JavaScript-%EB%B3%80%EC%88%98)

<br><br>

## 1-2. Event Loop

> 자바스크립트의 큰 특징 중 하나는 '**단일 스레드**' 기반의 언어라는 점이다. 스레드가 하나라면 동시에 하나의 작업만을 처리할 수 있다는 의미이지만, 실제 자바스크립트 환경을 생각해보면 **많은 작업이 동시에** 처리되고 있는 것을 볼 수 있다. 이때 **자바스크립트는 이벤트루프를 이용해서 비동기 방식으로 동시성을 지원**할 수 있다.

### 자바스크립트 런타임 환경

#### 📌 Javascript는 single threaded language이다.

- 언어자체에는 멀티쓰레딩이 없다.
- 자바스크립트가 동작하고 있는 브라우저라는 프로그램 안에서는 여러가지 쓰레드가 들어있다.
  → 브라우저. 즉 웹APIs 들을 이용시 멀티쓰레딩이 가능하다.
- 자바스크립트가 동작하고 있는 실행환경(런타임, Javascript Runtime Environment) 에서는 다양한 방식을 이용, 멀티쓰레딩 같은 효과를 얻을 수 있다.
- 자바스크립트가 실행되는 실행 환경 위에서는 멀티쓰레딩 뿐만 아니라 **이벤트 루프**를 이용, 다양한 동작 실행 가능하다.

✍️ 자바스크립트가 '단일 스레드' 기반의 언어라는 말은 '자바스크립트 엔진이 단일 호출 스택을 사용한다'는 관점에서만 사실이다. 실제 자바스크립트가 구동되는 환경(브라우저, Node.js등)에서는 주로 여러 개의 스레드가 사용되며, 이러한 구동 환경이 단일 호출 스택을 사용하는 자바스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 '이벤트 루프'인 것이다.

<br><br>

## 1-3. Hoisting

> **호이스팅**(Hoisting, 끌어올리다)이란, var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성을 말한다. (어디에 선언했냐에 상관없이 항상 제일 위로 선언을 끌어 올려준다.)

### var 키워드와 변수 호이스팅(Variable Hoisting)

변수는 3단계 (선언-초기화-할당)에 걸쳐 생성된다.

✍️ var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 즉 스코프에 변수를 등록(선언단계)하고 메모리에 변수를 위한 공간을 확보한 후 undefined로 초기화 한다. 그래서 변수 **선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기에 에러가 발생하지 않는다. 다만 undefined를 반환**한다. 이러한 현상을 **변수 호이스팅(Variable Hoisting)**이라한다.

하지만 `let` , `const` 는 `var` 와는 다르게 선언 단계와 초기화 단계가 분리되어 진행된다. 그래서 초기화 이전에 변수에 접근하려고 하면 참조 에러가 발생하는데, 변수가 아직 초기화 되지 않았기 때문이다.

let, const 변수의 선언 단계와 초기화 단계 사이를 일시적 사각 지대 (Temporal Dead Zone; TDZ)라고 부른다.
실제 코드에서 let 변수의 선언 또는 const 변수의 선언 및 할당 (const 의 경우 선언과 동시에 값 할당이 되어야 한다)이 나오기 전까지는 해당 변수는 TDZ에서 관리 한다고 생각하면 된다고 한다.
해당 코드가 나오기 전에 미리 사용을 하려고 할 경우 TDZ에서 ReferenceError를 발생 시키는 것이다.

![](https://velog.velcdn.com/images/seul06/post/031f4ff9-26e0-4051-851d-437d1f311384/image.png)

<br><br>

## 1-4. Closure

> 클로저는 **내부함수가 외부함수의 스코프에에 접근**할 수 있는 것을 가르킨다. 클로저는 자신이 생성될 때의 환경을 기억해야 하므로 메모리 차원에서 손해를 볼 수 있지만, **정보의 은닉, 상태유지** 등의 클로저의 특성을 이용해서 자바스크립트를 더욱 강력하게 해주는 기능이기도 하다.

- 자바스크립트 고유의 개념이 아닌, 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 특징이다.

- MDN에서는 '클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical environment)과의 조합'이라고 정의한다.

```javascript
function outer() {
  const x = 0;
  function inner() {
    console.log(x); // 0
  }
  return innter;
}
const func1 = outer();
func1();
```

클로저에 의해서 함수가 리턴이 될 때 inner함수 뿐만이 아니라 함수 외부에 있는 outer 렉시컬 환경까지 클로저로 반환이 되기 때문에 inner에서도 여전히 outer에 있는 변수에 접근이 가능하다.

> 📌 [클로저 정리](https://velog.io/@seul06/JavaScript-%ED%81%B4%EB%A1%9C%EC%A0%80)

<br>
reference)

[howdy-mj](https://www.howdy-mj.me/javascript/var-let-const/)
[var, let, const](https://javascriptforwp.com/var-let-const/)
[eventloop](https://meetup.toast.com/posts/89)
[호이스팅](https://velog.io/@seul06/JavaScript-%EB%B3%80%EC%88%98)
