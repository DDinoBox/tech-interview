# 브라우저 동작 방법

## 브라우저의 주요 기능

브라우저의 주요 기능은 **사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것**이다. 자원은 보통 HTML 문서지만 PDF나 이미지 또는 다른 형태일 수 있다. 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해진다.

브라우저의 UI는 서로 닮아 있는데 다음과 같은 요소들이 일반적이다.

- URI를 입력할 수 있는 주소 표시 줄
- 이전 버튼 / 다음 버튼
- 북마크
- 새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼
- 홈 버튼

## 브라우저의 기본 구조

1. UI: 주소 표지술, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분
2. 브라우저 엔진: UI와 렌더링 엔진 사이의 동작 제어
3. 렌더링 엔진: 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시
4. 통신: HTTP 요청과 같은 네트워크 호출에 사용. 통신은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행됨
5. UI 백엔드: 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용
6. 자바스크립트 해석기: 자바스크립트 코드를 해석하고 실행
7. 자료 저장소: 자료를 저장하는 계층. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 '웹 데이터 베이스'가 정의되어 있다.

## 렌더링 엔진

렌더링 엔진은 요청 받은 내용을 화면에 표시하는 일이다. 렌더링 엔진은 HTMl 및 XML 문서와 이미지를 표시할 수 있으며, 플러그인이나 브라우저 확장 기능을 이용해 PDF와 같은 다른 유형도 표시할 수 있다.

## 렌더링 엔진 동작 과정

렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 **보통 8KB 단위로 전송**된다.

1. DOM 트리 구축을 위한 HTML 파싱
2. 렌더 트리 구축
3. 렌더 트리 배치
4. 렌더 트리 그리기

### DOM(Document Object Model), CSSOM(CSS Object Model) 생성

- HTML을 파싱하여 DOM 노드를 만든다. 이 DOM 노드들을 병합하여 DOM 트리를 만든다.
- CSS를 파싱하여 CSSOM 트리를 만들게 된다.

**위 과정은 점진적으로 진행된다는 것이 중요**하다. 렌더링 엔진은 보다 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.

### 렌더 트리 구축(Attachment)

DOM 트리와 CSSOM 트리를 결합하여 표시해야 할 순서로 내용을 그려낼 수 있도록 렌더 트리를 형성한다. 이 과정을 Attachment라고 한다.

렌더 트리를 생성하려면 브라우저는 대략 3가지 작업을 수행한다.

- DOM 트리의 루트부터 노드 각각을 모두 탐색한다.
  - 이 때 화면에 표시되지 않는 일부 노드들(script, meta 태그 등)은 렌더 트리에서 제외된다.
  - 또한 CSS 속성 중 `display: none`과 같이 화면에서 숨겨지는 속성도 렌더 트리에 반영되지 않는다.
- 화면에 표시되는 각 노트에 대해 적절하게 일치하는 CSSOM 규칙을 찾아 적용한다.
- 화면에 표시되는 노드를 콘텐츠 및 계산된 스타일과 함께 렌더트리로 생성된다.

### 렌더 트리 배치(Layout or Reflow)

렌더 트리가 생성되고, 기기의 뷰포트 내에서 렌더 트리의 노드가 정확한 위치와 크기를 계산한다. 이 때 모든 상대적인 값이 픽셀값으로 변환된다. CSS에 상대적인 값인 `%`, `rem`, `vh`로 할당된 값들은 절대적인 값인 `px`단위로 변환된다. 이 과정을 **배치(Layout) 또는 Reflow**라고 한다.

### 렌더 트리 그리기(Paint)

렌더 트리의 각 노드를 화면의 실제 픽셀로 나타낼 때 Painting 메서드가 호출된다. Painting 과정 후 브라우저 화면에 UI가 나타나게 된다.

#### 그리기 순서

실제로 요소가 stacking contexts에 쌓이는 순서는 아래와 같다. 스택은 뒤에서 앞으로 그려지기 때문에 이 순서는 Painting에 영향을 미친다. 블록 렌더러가 쌓이는 순서는 다음과 같다.

1. 배경 색
2. 배경 이미지
3. 테두리
4. 자식
5. 아웃라인

페인트 단계에서 메인 스레드는 페인트 기록(paint record)을 생성하기 위해 레이아웃 트리를 순회한다. 페인트 기록은 '배경 먼저, 다음은 텍스트, 그리고 직사각형'과 같이 페인팅 과정을 기록한 것이다.

#### 동적 변경

브라우저는 변경에 대해 가능한 한 최소한의 동작으로 반응하려고 노력한다. 예를 들어 `div` 요소 한 개의 의 색깔이 바뀌면 해당 요소의 리페인팅만 발생한다.
요소의 위치가 바뀌면 요소와 자식 그리고 형제의 리페인팅과 재배치가 발생한다.
DOM 노드를 추가하면 노드의 리페인팅과 재 배치가 발생한다. `html` 요소의 글꼴 크기를 변경하는 것과 같은 큰 변경은 캐시를 무효화하고 트리 전체의 배치(Layout)와 리페인팅이 발생한다.

## Reflow와 Repaint

### Reflow

렌더 트리와 각 요소들의 크기, 위치를 다시 계산해주는 과정. `Reflow`가 일어나는 대표적인 과정은 다음과 같다.

- DOM 노드의 추가/제거
- DOM 노드의 위치 변경
- DOM 노드의 크기 변경(`margin`, `padding`, `border`, `width`, `height` 등)
- CSS3 애니메이션과 트랜지션
- 폰트 변경, 텍스트 내용 변경
- 이미지 크기 변경
- `offset`, `scrollTop`과 같은 계산된 스타일 정보 요청
- 페이지 초기 렌더링
- 윈도우 리사이징

이외에도 화면의 구조가 변경되었다면 Reflow가 발생한다고 이해하면 된다.

### Repaint

Reflow된 렌더 트리를 다시 화면에 그려주는 과정. 화면의 구조가 변경되는 경우에는 `Reflow`와 `Repaint`가 모두 발생한다.

화면의 구조가 변경되지 않는 화면 변화의 경우 `Repaint`만 발생한다. `opacity`, `background-color`, `visibility`, `outline` 등의 스타일 변경 시에는 Repaint만 동작한다.
